"""
TC_L_02 - Secure Firmware Update - InstallScheduled
Use case: L01 | Requirements: L01.FR.01, L01.FR.11, L01.FR.15
L01.FR.01: Whenever the Charging Station enters a new state in the firmware update process, the Charging Station SHALL send a FirmwareStatusNotificationRequest message to the CSMS with this new status.
    Precondition: Whenever the Charging Station enters a new state in the firmware update process.
L01.FR.11: For security purposes the CSMS SHALL include the Firmware Signing certificate in the UpdateFirmwareRequest.
L01.FR.15: When a Charging Station needs to reboot before installing the downloaded firmware, the Charging Station SHALL send a FirmwareStatusNotificationRequest with status InstallRebooting, before rebooting.
    Precondition: When a Charging Station needs to reboot before installing the downloaded firmware.
System under test: CSMS

Description:
    This test case covers the secure firmware update process where the installDateTime is in the future.
    The Charging Station downloads and verifies the firmware, then waits for the installDateTime before
    proceeding with installation.

Purpose:
    To verify if the CSMS handles a firmware update with a scheduled install time, where the CS reports
    InstallScheduled status while waiting for the installDateTime.

Main:
    1. CSMS sends UpdateFirmwareRequest with firmware.installDateTime in the future
    2. CS responds Accepted
    3. CS sends FirmwareStatusNotification progression:
       Downloading -> Downloaded -> SignatureVerified -> InstallScheduled -> Installing ->
       InstallRebooting -> BootNotification(FirmwareUpdate) -> StatusNotification -> Installed

Tool validations:
    * Step 1: UpdateFirmwareRequest
      - firmware.installDateTime is in the future
    * Step 16: BootNotificationResponse
      - status = Accepted

Configuration:
    CSMS_ADDRESS              - WebSocket URL of the CSMS
    BASIC_AUTH_CP             - Charge Point identifier
    BASIC_AUTH_CP_PASSWORD    - Charge Point password
    CONFIGURED_EVSE_ID        - EVSE id (default 1)
    CONFIGURED_CONNECTOR_ID   - Connector id (default 1)
    CSMS_ACTION_TIMEOUT       - Seconds to wait for CSMS action (default 30)
"""
import asyncio
import logging
import os
import sys
import time
from datetime import datetime

import pytest
import websockets

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from ocpp.v201.enums import (
    RegistrationStatusEnumType,
    ConnectorStatusEnumType,
    FirmwareStatusEnumType,
    EventTriggerEnumType,
    EventNotificationEnumType,
)
from ocpp.v201.datatypes import EventDataType, ComponentType, VariableType

from tzi_charge_point import TziChargePoint
from utils import get_basic_auth_headers, now_iso

logging.basicConfig(level=logging.INFO)

CSMS_ADDRESS = os.environ.get('CSMS_ADDRESS', 'ws://localhost:9000')
BASIC_AUTH_CP = os.environ.get('BASIC_AUTH_CP', 'CP_1')
BASIC_AUTH_CP_PASSWORD = os.environ.get('BASIC_AUTH_CP_PASSWORD', '0123456789123456')
EVSE_ID = int(os.environ.get('CONFIGURED_EVSE_ID', '1'))
CONNECTOR_ID = int(os.environ.get('CONFIGURED_CONNECTOR_ID', '1'))
CSMS_ACTION_TIMEOUT = int(os.environ.get('CSMS_ACTION_TIMEOUT', '30'))


@pytest.mark.asyncio
async def test_tc_l_02():
    """Secure Firmware Update - InstallScheduled."""
    cp_id = BASIC_AUTH_CP
    uri = f'{CSMS_ADDRESS}/{cp_id}'
    headers = get_basic_auth_headers(cp_id, BASIC_AUTH_CP_PASSWORD)

    ws = await websockets.connect(
        uri=uri,
        subprotocols=['ocpp2.0.1'],
        extra_headers=headers,
    )
    time.sleep(0.5)

    cp = TziChargePoint(cp_id, ws)
    start_task = asyncio.create_task(cp.start())

    # Boot and establish session
    boot_response = await cp.send_boot_notification()
    assert boot_response.status == RegistrationStatusEnumType.accepted

    await cp.send_status_notification(CONNECTOR_ID, ConnectorStatusEnumType.available)

    # Step 1-2: Wait for CSMS to send UpdateFirmwareRequest
    await asyncio.wait_for(
        cp._received_update_firmware.wait(),
        timeout=CSMS_ACTION_TIMEOUT,
    )

    # Validate UpdateFirmwareRequest content
    assert cp._update_firmware_data is not None
    firmware = cp._update_firmware_data['firmware']

    # Tool validation Step 1: firmware.installDateTime should be in the future
    install_dt = firmware.get('install_date_time') or firmware.get('installDateTime')
    assert install_dt is not None, \
        "firmware.installDateTime must be present in UpdateFirmwareRequest"
    install_dt_parsed = datetime.fromisoformat(install_dt.replace('Z', '+00:00'))
    assert install_dt_parsed > datetime.now(install_dt_parsed.tzinfo), \
        f"firmware.installDateTime must be in the future, got {install_dt}"
    logging.info(f"firmware.installDateTime = {install_dt} (validated as future)")

    # CS responded with Accepted (handled by on_update_firmware handler)

    # FirmwareStatusNotification - Downloading
    resp = await cp.send_firmware_status_notification_request(
        FirmwareStatusEnumType.downloading
    )
    assert resp is not None

    # FirmwareStatusNotification - Downloaded
    resp = await cp.send_firmware_status_notification_request(
        FirmwareStatusEnumType.downloaded
    )
    assert resp is not None

    # FirmwareStatusNotification - SignatureVerified
    resp = await cp.send_firmware_status_notification_request(
        FirmwareStatusEnumType.signature_verified
    )
    assert resp is not None

    # FirmwareStatusNotification - InstallScheduled (waiting for installDateTime)
    resp = await cp.send_firmware_status_notification_request(
        FirmwareStatusEnumType.install_scheduled
    )
    assert resp is not None

    # Simulate waiting for installDateTime
    await asyncio.sleep(1)

    # FirmwareStatusNotification - Installing
    resp = await cp.send_firmware_status_notification_request(
        FirmwareStatusEnumType.installing
    )
    assert resp is not None

    # FirmwareStatusNotification - InstallRebooting
    resp = await cp.send_firmware_status_notification_request(
        FirmwareStatusEnumType.install_rebooting
    )
    assert resp is not None

    # BootNotification with FirmwareUpdate reason
    boot_response = await cp.send_boot_notification_with_reason('FirmwareUpdate')
    assert boot_response.status == RegistrationStatusEnumType.accepted, \
        f"Expected BootNotificationResponse status=Accepted, got {boot_response.status}"

    # StatusNotification - Available + NotifyEvent
    await cp.send_status_notification(CONNECTOR_ID, ConnectorStatusEnumType.available)

    event_data = [
        EventDataType(
            trigger=EventTriggerEnumType.delta,
            actual_value='Available',
            component=ComponentType(name='Connector', evse={"id": EVSE_ID}),
            variable=VariableType(name='AvailabilityState'),
            timestamp=now_iso(),
            event_id=EVSE_ID,
            event_notification_type=EventNotificationEnumType.custom_monitor,
        )
    ]
    await cp.send_notify_event(data=event_data)

    # FirmwareStatusNotification - Installed
    resp = await cp.send_firmware_status_notification_request(
        FirmwareStatusEnumType.installed
    )
    assert resp is not None

    logging.info("TC_L_02 completed successfully")
    start_task.cancel()
    await ws.close()
